---
title: "Interesting ways to select dataframe columns"
description: |
  You will learn how to select some specific columns of a tidy dataframe professionally.
author:
  - name: "Mahyar Sharifi"
    occupation: "Internship"
    affiliation: "DataMotto"
    url: "https://www.linkedin.com/in/mahyar-sharifi-06126616a"
    img: "Mahyar.jpeg"
    lang: ["python", "r"]
tech:
  - lang: r
    pkgs: ["dyplyr", "palmerpenguins"]
  - lang: python
    pkgs: ["pandas", "seaborn"]
date:
  created: "2021-07-11"
  last_updated: "2021-07-11"
categories: "Wrangling"
applications: "General"
cover_image: NULL
slug: "interesting-ways-to-select-dataframe-columns"
output: DataMotto::Dotto
---

```{r DataMotto, echo=FALSE}
DataMotto::use_Dotto()
```

<!-- Dot 1, lang: r,python ------------------------------------------------>

```{block, Dot = 1, part = "Instruction", lang = "r"}
**Dataset Description**
The Palmer Archipelago penguin dataset has been becoming famous, likes the Iris dataset. This dataset is a great intro dataset for data exploration & visualization. 
The penguin dataset contains four numerical features, two categorical features, and a binary feature. These features are:
   1. **bill_length_mm**.
  
   2. **bill_depth_mm**
  
   3. **flipper_length_mm**
  
   4. **body_mass_g**
   
   5. **year (Num)**
  
   6. **species:** (Chinstrap, Adélie, or Gentoo)
  
   7. **island:** (Dream, Torgersen, or Biscoe)
  
   8. **sex**
To import this dataset, we use `palmerpenguins` packages.
After the **penguins** dataset imported, we try some intresting ways to select columns in dplyr library.
```


```{block, Dot = 1, part = "Instruction", lang = "python"}
**Dataset Description**
The Palmer Archipelago penguin dataset has been becoming famous, likes the Iris dataset. This dataset is a great intro dataset for data exploration & visualization. 
The penguin dataset contains four numerical features(Num), two categorical features(Cat), and a binary feature(Bin). These features are:
   1. **bill_length_mm (Num)**.
  
   2. **bill_depth_mm (Num)**
  
   3. **flipper_length_mm (Num)**
  
   4. **body_mass_g (Num)**
  
   5. **species (Cat)** (Chinstrap, Adélie, or Gentoo)
  
   6. **island (Cat)** (Dream, Torgersen, or Biscoe)
  
   7. **sex (Cat)**
To import this dataset, we use `seaborn` packages.
After the **penguins** dataset imported, we try some intresting ways to select columns in pandas packages.
```

```{r, Dot = 1, part = "Code", echo = T, eval = F }
#Import Packages
library(palmerpenguins)
library(dplyr)
#Load Penguins dataset
penguins = palmerpenguins::penguins
#Show five sample rows
sample_n(penguins,5)
```

```{python, Dot = 1, part = "Code", echo = T, eval = F }
#Import package
import seaborn as sns
#Load Penguins dataset
penguins = sns.load_dataset("penguins")
#Show five sample rows
penguins.sample(5)
```

```{r, Dot = 1, part = "Result", echo = F, eval = T}
#Import Packages
library(palmerpenguins)
library(dplyr)
#Load Penguins dataset
penguins = palmerpenguins::penguins
#Show five sample rows
sample_n(penguins,5)
```


```{python, Dot = 1, part = "Result", echo = F, eval = T}
#Import package
import seaborn as sns
#Load Penguins dataset
penguins = sns.load_dataset("penguins")
#Show five sample rows
penguins.sample(5)
```

<!-- Dot 2, lang: r,python ------------------------------------------------>

```{block, Dot = 2, part = "Instruction", lang = "r"}
**Select by a name or list of names**
Sometimes we want to select single or multiple columns with the name. In this case, we need to write the column's name.
The names or numbers order is essential for columns order. 
For example, we need just the gender column or two bill columns.
```

```{block, Dot = 2, part = "Instruction", lang = "python"}
**Select by a name or list of names**
Sometimes we want to select single or multiple columns with the name. In this case, we need to write the column's names. The names order is essential for columns order.
For example, we need just the sex column and two bill columns.
```

```{r, Dot = 2, part = "Code", echo = T, eval = F }
# Select 'sex' columns
colnames(select(penguins, c('sex')))
# Select two bill columns
colnames(select(penguins, c('bill_length_mm',
                            'bill_depth_mm')))
```

```{python, Dot = 2, part = "Code", echo = T, eval = F }
# Select 'sex' columns
print(penguins[['sex']].columns)
# Select two bill columns
print(penguins[['bill_length_mm',
'bill_depth_mm']].columns)
```

```{r, Dot = 2, part = "Result", echo = F, eval = T }
# Select 'sex' columns
colnames(select(penguins, c('sex')))
# Select two bill columns
colnames(select(penguins, c('bill_length_mm',
                            'bill_depth_mm')))
```

```{python, Dot = 2, part = "Result", echo = F, eval = T }
# Select 'sex' columns
print(penguins[['sex']].columns)
# Select two bill columns
print(penguins[['bill_length_mm',
'bill_depth_mm']].columns)
```

<!-- Dot 3, lang: r,python ------------------------------------------------>

```{block, Dot = 3, part = "Instruction", lang = "r"}
**Check from a list**
Similar to the second Dotto, we have a list of columns name, and we want to select columns in this list or select columns are not in this list.
In this case, we use two function: 
 - `%in%()`
For example, we need select a dataset that contains only two bill columns, and select a dataset that contains all columns except two bill columns. 
```

```{block, Dot = 3, part = "Instruction", lang = "python"}
**Check from a list**
Similar to the second Dotto, we have a list of columns name, and we want to select columns in this list or select columns are not in this list.
In this case, we use two function: 
 - `isin()` 
 - `difference()` or `~ isin()`
For example, we need select a dataset that contains only two bill columns, and select a dataset that contains all columns except two bill columns. 
```

```{r, Dot = 3, part = "Code", echo = T, eval = F }
#Select dataset that contains bill_length_mm and' bill_depth_mm
colnames(penguins[, (colnames(penguins) %in% 
                       c('bill_length_mm',
                         'bill_depth_mm'))])
# Select dataset that contains all columns except bill_length_mm & bill_depth_mm
colnames(penguins[, !(colnames(penguins) %in%
                        c('bill_length_mm',
                          'bill_depth_mm'))])
```

```{python, Dot = 3, part = "Code", echo = T, eval = F }
# Select dataset that contains bill_length_mm & bill_depth_mm
print(penguins[penguins.columns[
                  penguins.columns.isin(['bill_length_mm',
                                     'bill_depth_mm'])]].columns)
# Select dataset that contains all columns except bill_length_mm & bill_depth_mm _First Way
print(penguins[penguins.columns.difference(
                            ['bill_length_mm',
                            'bill_depth_mm'])].columns)
                                           
# Select dataset that contains all columns except bill_length_mm & bill_depth_mm _Second Way                                           
print(penguins[penguins.columns[
                  ~penguins.columns.isin(['bill_length_mm',
                                       'bill_depth_mm'])]].columns)
                                     
```

```{r, Dot = 3, part = "Result", echo = F, eval = T }
#Select dataset that contains bill_length_mm and' bill_depth_mm
colnames(penguins[, (colnames(penguins) %in% 
                       c('bill_length_mm',
                         'bill_depth_mm'))])
# Select dataset that contains all columns except bill_length_mm & bill_depth_mm
colnames(penguins[, !(colnames(penguins) %in%
                        c('bill_length_mm',
                          'bill_depth_mm'))])
```

```{python, Dot = 3, part = "Result", echo = F, eval = T }
# Select dataset that contains bill_length_mm & bill_depth_mm
print(penguins[penguins.columns[
                  penguins.columns.isin(['bill_length_mm',
                                     'bill_depth_mm'])]].columns)
# Select dataset that contains all columns except bill_length_mm & bill_depth_mm _First Way
print(penguins[penguins.columns.difference(
                            ['bill_length_mm',
                            'bill_depth_mm'])].columns)
                                           
# Select dataset that contains all columns except bill_length_mm & bill_depth_mm _Second Way                                           
print(penguins[penguins.columns[
                  ~penguins.columns.isin(['bill_length_mm',
                                       'bill_depth_mm'])]].columns)
                                       
```

<!-- Dot 4, lang: r,python ------------------------------------------------>

```{block, Dot = 4, part = "Instruction", lang = "r"}
**Select()**
Another way to select columns in pandas data-frame is to use `select()` function from `dplyr`. The names or numbers order is essential for columns order. 
```

```{block, Dot = 4, part = "Instruction", lang = "python"}
**Slicing 1**
Another way to select columns in pandas data-frame is to use `iloc` and `loc` functions. The names or numbers order is essential for columns order. 
   1. `iloc` function selects rows and columns by the row and column numbers. 
    + dataframe.iloc[ rows number, [columns number]]
    
 
   2. `loc` function selects rows and columns by the row and column names. 
    + dataframe.loc[ rows names, [columns name]]
    
In these functions, we can filter rows, too. For yhis purpose, we can filter rows by condition.
```

```{r, Dot = 4, part = "Code", echo = T, eval = F }
#Select 'sex' and 'island' columns by column's name
colnames(penguins %>% 
           select(c('sex',
                               'island')))
#Select 'sex' and 'island' columns by column's number
colnames(penguins %>% 
           select(c(7, 2)))
```

```{python, Dot = 4, part = "Code", echo = T, eval = F }
#Select 'sex' and 'island' columns by column's name
print(penguins.loc[:, ['sex', 'island']].columns)
#Select 'sex' and 'island' columns by column's number
print(penguins.iloc[:, [6,1]].columns)
```

```{r, Dot = 4, part = "Result", echo = F, eval = T }
#Select 'sex' and 'island' columns by column's name
colnames(penguins %>% 
           select(c('sex', 'island')))
         
#Select 'sex' and 'island' columns by column's number
colnames(penguins %>%
           select(c(7, 2)))
```

```{python, Dot = 4, part = "Result", echo = F, eval = T }
#Select 'sex' and 'island' columns by column's name
print(penguins.loc[:, ['sex', 'island']].columns)
#Select 'sex' and 'island' columns by column's number
print(penguins.iloc[:, [6,1]].columns)
```

<!-- Dot 5, lang: r,python ------------------------------------------------>

```{block, Dot = 5, part = "Instruction", lang = "r"}
**Filter() and Select()**
Sometimes we want to select columns and filter rows simultaneously. In this case we can use `%>%` with `select()` to select columns and use `filter()` to select rows.
```

```{block, Dot = 5, part = "Instruction", lang = "python"}
**Slicing 2**
In the iloc and loc functions, we can filter rows simultaneously by selecting columns.
dataframe.loc[ criteria for rows, crteria for columns]
dataframe.iloc[ criteria for rows, crteria for columns]
```

```{r, Dot = 5, part = "Code", echo = T, eval = F }
# Select 'bill_depth_mm' and 'bill_length_mm' columns for Male sex
colnames(penguins %>%
    filter(sex == 'male')%>%
    select(c('bill_depth_mm',
             'bill_length_mm')))
```

```{python, Dot = 5, part = "Code", echo = T, eval = F }
# Select 'bill_depth_mm' and 'bill_length_mm' columns for Male sex
penguins.loc[penguins['sex'] == 'Male',
['bill_depth_mm', 'bill_length_mm']].head(5)
```

```{r, Dot = 5, part = "Result", echo = F, eval = T }
# Select 'bill_depth_mm' and 'bill_length_mm' columns for Male sex
colnames(penguins %>%
    filter(sex == 'male')%>%
    select(c('bill_depth_mm',
             'bill_length_mm')))
```

```{python, Dot = 5, part = "Result", echo = F, eval = T }
# Select 'bill_depth_mm' and 'bill_length_mm' columns for Male sex
penguins.loc[penguins['sex'] == 'Male', ['bill_depth_mm', 'bill_length_mm']].head(5)
```

<!-- Dot 6, lang: r,python ------------------------------------------------>

```{block, Dot = 6, part = "Instruction", lang = "r"}
**Select a type**
Many datasets contain different variable types. In some situations, we need to select a specific type. To identify all column data types, we use `is.numeric` or etc, and then we select data types.  
```

```{block, Dot = 6, part = "Instruction", lang = "python"}
**Select a type**
Many datasets contain different variable types. In some situations, we need to select a specific type. To identify all column data types, we use `dataframe.dtypes`, and then we select data types.  
```

```{r, Dot = 6, part = "Code", echo = T, eval = F }
#Select dataset that contains numeric value
colnames(penguins %>%
  select_if(is.numeric))
```

```{python, Dot = 6, part = "Code", echo = T, eval = F }
#Select dataset that contains numeric value
print(penguins.loc[:, (penguins.dtypes == 'float64').values].columns)
```

```{r, Dot = 6, part = "Result", echo = F, eval = T }
#Select dataset that contains numeric value
colnames(penguins %>%
  select_if(is.numeric))
```

```{python, Dot = 6, part = "Result", echo = F, eval = T }
#Select dataset that contains numeric value
print(penguins.loc[:, (penguins.dtypes == 'float64').values].columns)
```

<!-- Dot 7, lang: r,python ------------------------------------------------>

```{block, Dot = 7, part = "Instruction", lang = "r"}
**Contains a specific character**
The other way to select columns is to select with starting and ending characters or contains specific characters. For this purpose we use `starts_with`, `ends_with` and `contains` to find particular columns with their names.
In this dot, we want to select columns that **start** with **`bill`** and select columns that **finish** with **`_mm`** and select columns that contain **`length`**.
```

```{block, Dot = 7, part = "Instruction", lang = "python"}
**Contains a specific character**
The other way to select columns is to select with starting and ending characters. For this purpose, first, we need to get the columns' names with `dataframe.columns.str`. 
Then we use `startswith` and `endswith` to find particular columns with their names.
Some times
Sometimes we want to select columns that contain some specific characters. For this idea, we can use the `re` package and its searching function call `search()`.
In this dot, we want to select columns that **start** with **`bill`** and select columns that **finish** with **`_mm`** and select columns that contain **`length`**.
```

```{r, Dot = 7, part = "Code", echo = T, eval = F }
#Select columns which start with 'bill'
colnames(penguins %>%
    select(starts_with('bill')))
#Select columns which end with 'mm'
colnames(penguins %>%
    select(ends_with('mm')))
#Select columns which contain 'length'
colnames(penguins %>%
    select(contains('length')))
```

```{python, Dot = 7, part = "Code", echo = T, eval = F }
#Select columns which start with 'bill'
print(penguins.loc[:,penguins.columns.str.startswith('bill')].columns)
#Select columns which end with 'mm'
print(penguins.loc[:,penguins.columns.str.endswith('mm')].columns)
#Import re packages
from re import search
#Select columns which contain 'length'
print(penguins.loc[:,[True if search('length+',column) else False for column in penguins.columns]].columns)
```

```{r, Dot = 7, part = "Result", echo = F, eval = T }
#Select columns which start with 'bill'
colnames(penguins %>%
    select(starts_with('bill')))
#Select columns which end with 'mm'
colnames(penguins %>%
    select(ends_with('mm')))
#Select columns which contain 'length'
colnames(penguins %>%
    select(contains('length')))
```

```{python, Dot = 7, part = "Result", echo = F, eval = T }
#Select columns which start with 'bill'
print(penguins.loc[:,penguins.columns.str.startswith('bill')].columns)
#Select columns which end with 'mm'
print(penguins.loc[:,penguins.columns.str.endswith('mm')].columns)
#Import re packages
from re import search
#Select columns which contain 'length'
print(penguins.loc[:,[True if search('length+',column) else False for column in penguins.columns]].columns)
```

<!-- Dot 8, lang: r,python ------------------------------------------------>

```{block, Dot = 8, part = "Instruction", lang = "r"}
**Check a condition**
Sometimes we want to select columns by condition. For instance, select columns that all of the values of the columns or any of them are upper than a specific value.  Another example, some times we want to select columns that the mean of the column is upper or lower than a particular value. For these purposes, we use `sapply` and `select_if` to select columns that meet the conditions.
In this dot, first, we select numeric columns then drop `Nan` from the `penguins`' dataset. Finally, we select columns that all rows are greater than 50, columns that if one row is greater than 50, and columns that mean column is greater than 50.  
```

```{block, Dot = 8, part = "Instruction", lang = "python"}
**Check a condition**
Sometimes we want to select columns by condition. For instance, select columns that all of the values of the columns or any of them are upper than a specific value.  Another example, some times we want to select columns that the mean of the column is upper or lower than a particular value. For these purposes, we use `all()` and `any()` to select columns that meet the conditions.
In this dot, first, we select numeric columns then drop `Nan` from the `penguins`' dataset. Finally, we select columns that all rows are greater than 50, columns that if one row is greater than 50, and columns that mean column is greater than 50. 
```

```{r, Dot = 8, part = "Code", echo = T, eval = F }
#Select numeric columns without Nan
df_without_na <- penguins %>%
  select_if(is.numeric) %>%
  na.omit()
#Select columns that if one row is greater than 50
colnames(df_without_na %>% 
         select_if(as.vector(sapply(df_without_na, min) > 50)))
#Select columns that mean column is greater than 50
colnames(df_without_na %>% 
         select_if(as.vector(sapply(df_without_na, mean) > 50)))
```

```{python, Dot = 8, part = "Code", echo = T, eval = F }
#Select numeric columns without Nan
df_without_na = penguins.loc[:,(penguins.dtypes == 'float64').values].dropna()
#Select columns that all rows are greater than 50
print(df_without_na.loc[:,[(df_without_na[col] > 50).all() for col in df_without_na.columns]].columns)
#Select columns that if one row is greater than 50
print(df_without_na.loc[:,[(df_without_na[col] > 50).any() for col in df_without_na.columns]].columns)
#Select columns that mean column is greater than 50
print(df_without_na.loc[:,[(df_without_na[col].mean() > 50) for col in df_without_na.columns]].columns)
```

```{r, Dot = 8, part = "Result", echo = F, eval = T }
#Select numeric columns without Nan
df_without_na <- penguins %>%
  select_if(is.numeric) %>%
  na.omit()
#Select columns that if one row is greater than 50
colnames(df_without_na %>% 
         select_if(as.vector(sapply(df_without_na, min) > 50)))
#Select columns that mean column is greater than 50
colnames(df_without_na %>% 
         select_if(as.vector(sapply(df_without_na, mean) > 50)))
```

```{python, Dot = 8, part = "Result", echo = F, eval = T }
#Select numeric columns without Nan
df_without_na = penguins.loc[:,(penguins.dtypes == 'float64').values].dropna()
#Select columns that all rows are greater than 50
print(df_without_na.loc[:,[(df_without_na[col] > 50).all() for col in df_without_na.columns]].columns)
#Select columns that if one row is greater than 50
print(df_without_na.loc[:,[(df_without_na[col] > 50).any() for col in df_without_na.columns]].columns)
#Select columns that mean column is greater than 50
print(df_without_na.loc[:,[(df_without_na[col].mean() > 50) for col in df_without_na.columns]].columns)
```
